% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hierarchical_coverage_regex.R
\name{hierarchical_coverage_regex}
\alias{hierarchical_coverage_regex}
\title{Hierarchical Coverage of Regexes}
\usage{
hierarchical_coverage_regex(
  text.var,
  term.list,
  ignore.case = TRUE,
  sort = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{text.var}{A text vector (vector of strings).}

\item{term.list}{A list of named character vectors to match against \code{x}.}

\item{ignore.case}{logical.  Should case be ignored in matching the
\code{terms} against \code{x}?}

\item{sort}{logical.  If \code{TRUE} the output is sorted by highest unique
gain.  If \code{FALSE} order of term input is retained.}

\item{verbose}{If \code{TRUE} each iteration of the \code{for} loop prints
\code{i of n}.}

\item{\ldots}{ignored.}
}
\value{
Returns a \code{\link[base]{data.frame}} with 7 columns:
\describe{
  \item{step}{the order in which the regex was searched for}
  \item{name}{the human readable name of the bound regex group}
  \item{unique_prop}{the unique prop coverage of the regex}
  \item{unique_n}{the unique n coverage of the regex}
  \item{cum_prop}{the cumulative prop coverage of the regex}
  \item{cum_n}{the cumulative n coverage of the regex}
  \item{regex}{the bound (|) regex that corresponds to \code{name}}
}
}
\description{
The unique coverage of a text vector by a regex after partitioning out the
elements matched by previous regexes.
}
\examples{
regs <- setNames(
    list(c('(?i)sam', "(?i)\\\\bam"), '^I', '(?i)(do|will) not', '(?i)(do|will)'),
    c('am', 'I', "won't")
)
(out <- hierarchical_coverage_regex(sam_i_am, regs, ignore.case=FALSE))
summary(out)
plot(out)
plot(out, mark.one = TRUE)

# Use unnamed vectors for `term.list` too
hierarchical_coverage_regex(sam_i_am, unlist(regs, use.names = FALSE), ignore.case=FALSE)
}
\seealso{
Other hierarchical_coverage functions: 
\code{\link{hierarchical_coverage_term}()}
}
\concept{hierarchical_coverage functions}
\keyword{coverage}

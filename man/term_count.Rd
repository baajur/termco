% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/term_count.R
\name{term_count}
\alias{term_count}
\title{Search For and Count Terms}
\usage{
term_count(text.var, grouping.var = NULL, term.list, ignore.case = TRUE,
  pretty = ifelse(isTRUE(grouping.var), FALSE, TRUE), group.names, ...)
}
\arguments{
\item{text.var}{The text string variable.}

\item{grouping.var}{The grouping variable(s).  Default \code{NULL} generates
one word list for all text.  Also takes a single grouping variable or a list
of 1 or more grouping variables.  If \code{TRUE} an \code{id} variable is
used with a \code{seq_along} the \code{text.var}.}

\item{term.list}{A list of named character vectors.  `code{term_count} can
be used in a hierarchical fashion as well; that is a list of regexes can be
passed and counted and then a second (or more) pass can be taken wit a new
set of regexes on only those rows/text elements that were left untagged
(count \code{\link[base]{rowSums}} is zero).  This is accomplished by passing
a \code{\link[base]{list}} of \code{\link[base]{list}}s of regexes.
See \bold{Examples} for the \strong{hierarchical terms} section for a
demonstration.}

\item{ignore.case}{logical.  If \code{FALSE}, the pattern matching is case
sensitive and if \code{TRUE}, case is ignored during matching.}

\item{pretty}{logical.  If \code{TRUE} pretty printing is used.  Pretty
printing can be turned off globally by setting
\code{options(termco_pretty = FALSE)}.}

\item{group.names}{A vector of names that corresponds to group.  Generally
for internal use.}

\item{\ldots}{ignored.}
}
\value{
Returns a \code{\link[dplyr]{tbl_df}} object of term counts by
grouping variable.
}
\description{
\code{term_count} - Search a string by any number of grouping variables for
categories (themes) of grouped root terms/substrings.
}
\note{
Note that while a \code{\link[termco]{term_count}} object prints as a
combination of integer counts and weighted (default percent of terms) in
parenthesis the underlying object is actually a \code{\link[dplyr]{tbl_df}}
of integer term/substring counts.  The user can alter a
\code{\link[termco]{term_count}} object to print as integer permanently using
the \code{\link[termco]{as_count}} function.  A percent \emph{Coverage} also
prints.  This is the rate of grouping variables with no term found (i.e.,
\code{\link[base]{rowSums}} is zero for terms).  For more details on coverage
see \code{\link[termco]{coverage}}.
}
\examples{
\dontrun{
data(presidential_debates_2012)

discoure_markers <- list(
    response_cries = c("\\\\boh", "\\\\bah", "\\\\baha", "\\\\bouch", "yuk"),
    back_channels = c("uh[- ]huh", "uhuh", "yeah"),
    summons = "hey",
    justification = "because"
)

(markers <- with(presidential_debates_2012,
    term_count(dialogue, list(person, time), discoure_markers)
))

print(markers, pretty = FALSE)
print(markers, zero.replace = "_")
plot(markers)
plot(markers, labels=TRUE)

# permanently remove pretty printing
(markers2 <- as_count(markers))

# manipulating the output in a dplyr chain
library(dplyr)

presidential_debates_2012 \%>\%
    with(., term_count(dialogue, list(person, time), discoure_markers)) \%>\%
    as_count()  # removes pretty print method (not necessary to manipulate)

presidential_debates_2012 \%>\%
    with(., term_count(dialogue, list(person, time), discoure_markers)) \%>\%
    mutate(totals = response_cries + back_channels + summons + justification) \%>\%
    arrange(-totals)

## hierarchical terms
trms <- frequent_terms(presidential_debates_2012[["dialogue"]])[[1]]

discoure_markers <- list(
    response_cries = c("\\\\boh", "\\\\bah", "\\\\baha", "\\\\bouch", "yuk"),
    back_channels = c("uh[- ]huh", "uhuh", "yeah"),
    summons = "hey",
    justification = "because"
)

dbl_list <- list(
    discoure_markers,
    setNames(as.list(trms[1:8]), trms[1:8]),
    setNames(as.list(trms[9:length(trms)]), trms[9:length(trms)])
)

x <- with(presidential_debates_2012,
    term_count(dialogue, TRUE, dbl_list)
)

coverage(x)

## Auto mapping hierarchical terms w/ duplicate names
trpl_list <- list(
    list(
        response_cries = c("\\\\boh", "\\\\bah", "\\\\baha", "\\\\bouch", "yuk"),
        back_channels = c("uh[- ]huh", "uhuh", "yeah"),
        summons = "hey",
        justification = "because"
    ),
    list(summons ='the'),
    list(summons = 'it', justification = 'ed\\\\s')
)

(x2 <- with(presidential_debates_2012, term_count(dialogue, TRUE, trpl_list)))

## get the pre-collapse hierarchical coverage
attributes(x2)[['pre_collapse_coverage']]
}
}
\keyword{substring}
\keyword{term}

